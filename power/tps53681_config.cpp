/*
 * Copyright (c) 2012 Xilinx, Inc.  All rights reserved.
 *
 * Xilinx, Inc.
 * XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A
 * COURTESY TO YOU.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
 * ONE POSSIBLE   IMPLEMENTATION OF THIS FEATURE, APPLICATION OR
 * STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION
 * IS FREE FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE
 * FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.
 * XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO
 * THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO
 * ANY WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE
 * FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <sys/mman.h>
#include <linux/limits.h>
#include <string>
#include <fstream>
#include <map>
#include <vector>

#include <boost/algorithm/string.hpp>
#include <boost/multiprecision/cpp_int.hpp>

using namespace std;

// Make the SDK console work in the debugger
#define printf(...) \
 fprintf(stdout, __VA_ARGS__); \
 fflush(stdout);

typedef long long int u64;
typedef unsigned int u32;


int run_command(char* cline, string& output)
{
	FILE *fp;
	int status;
	char path[PATH_MAX];

	output = "";

	fp = popen(cline, "r");
	if (fp == NULL)
	{
	  printf ("cannot popen\n");
	  return (-1);
	}
/* Handle error */;


	while (fgets(path, PATH_MAX, fp) != NULL)
	{
		output = string(path);
		boost::trim (output);
	}

	status = pclose(fp);
	if (status == -1)
	{
	  /* Error reported by pclose() */

	}
	else
	{
	  /* Use macros described under wait() to inspect `status' in order
		 to determine success/failure of command executed by popen() */
	}
	return status;
}


// argument is the Programming file generated by Fusion Digital Power Designer
int main(int argc, char * argv[])
{
	int bus = 2;
	string i2cset_send = "i2cset -y %d %s %s"; // bus chip addr

	string i2cset_byte = "i2cset -y %d %s %s 0x%02x 0x%02x i"; // bus chip addr value PEC
	string i2cget_byte = "i2cget -y %d %s %s b"; // bus chip addr

	string i2cset_word = "i2cset -y %d %s %s 0x%02x 0x%02x 0x%02x i"; // bus chip addr low_byte high_byte PEC
	string i2cget_word = "i2cget -y %d %s %s w"; // bus chip addr

	string i2cset_block = "i2cset -y %d %s %s 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x i"; // bus chip addr low-to-high-7-bytes PEC
	string i2cget_block = "i2cget -y %d %s %s w"; // bus chip addr

	char cmd[PATH_MAX];
	string output;
	int i, j;
	char line[1000];

	// open file
	FILE *fin = fopen (argv[1], "r");

	if (fin == NULL)
	{
		printf ("cannot open file: %s\n", argv[1]);
		exit (-1);
	}

	string chip;
	string reg ;
	string data;
	string comment;

	// dump registers
	while (fgets (line, 1000, fin) != NULL)
	{
		vector <string> fld;

        boost::split(fld, line, boost::is_any_of(",")); // split on commas

		if (fld[0].compare ("Comment") == 0)
		{
			comment = fld[1]; // store comment for the following command
			boost::trim (comment);
			continue; // skip comments
		}
		else if (fld[0].compare ("WriteByte") == 0)
		{
			chip = fld[1]; // can use as is
			reg  = fld[2]; // can use as is
			data = fld[3]; // need to split into bytes. Format: 0xDDPP, D = data, P = PEC
			boost::trim(chip);
			boost::trim(reg);
			boost::trim(data);
			uint64_t d64 = strtoull(data.c_str(), NULL, 16);
			uint8_t d = (d64 >> 8) & 0xff; // data byte
			uint8_t p = d64 & 0xff; // PEC byte

			sprintf (cmd, i2cset_byte.c_str(), bus, chip.c_str(), reg.c_str(), d, p);
			run_command (cmd, output);
			printf ("%s = %s // %s\n", cmd, output.c_str(), comment.c_str());
			comment = ""; // reset comment so it does not persist for commands without comments
		}
		else if (fld[0].compare ("ReadByte") == 0)
		{
			chip = fld[1]; // can use as is
			reg  = fld[2]; // can use as is
			data = fld[3]; // expected data byte

			sprintf (cmd, i2cget_byte.c_str(), bus, chip.c_str(), reg.c_str());
			run_command (cmd, output);
			printf ("%s = %s // %s\n", cmd, output.c_str(), comment.c_str());
			comment = ""; // reset comment so it does not persist for commands without comments
		}
		else if (fld[0].compare ("WriteWord") == 0)
		{
			chip = fld[1]; // can use as is
			reg  = fld[2]; // can use as is
			data = fld[3]; // need to split into bytes. Format: 0xDDPP, D = data, P = PEC
			boost::trim(chip);
			boost::trim(reg);
			boost::trim(data);
			uint64_t d64 = strtoull(data.c_str(), NULL, 16);
			uint8_t d[2];
			d[0] = (d64 >> 16) & 0xff; // low data byte
			d[1] = (d64 >> 8) & 0xff; //  highdata byte
			uint8_t p = d64 & 0xff; // PEC byte

			sprintf (cmd, i2cset_word.c_str(), bus, chip.c_str(), reg.c_str(), d[0], d[1], p);
			run_command (cmd, output);
			printf ("%s = %s // %s\n", cmd, output.c_str(), comment.c_str());
			comment = ""; // reset comment so it does not persist for commands without comments
		}
		else if (fld[0].compare ("ReadWord") == 0)
		{
			chip = fld[1]; // can use as is
			reg  = fld[2]; // can use as is
			data = fld[3]; // expected data word
			boost::trim(chip);
			boost::trim(reg);
			boost::trim(data);

			sprintf (cmd, i2cget_word.c_str(), bus, chip.c_str(), reg.c_str());
			run_command (cmd, output);
			printf ("%s = %s // %s\n", cmd, output.c_str(), comment.c_str());
			comment = ""; // reset comment so it does not persist for commands without comments
		}
		else if (fld[0].compare ("BlockWrite") == 0)
		{
			chip = fld[1]; // can use as is
			reg  = fld[2]; // can use as is
			data = fld[3]; // need to split into bytes. Format: 0xDDPP, D = data, P = PEC
			boost::trim(chip);
			boost::trim(reg);
			boost::trim(data);
			uint64_t d64 = strtoull(data.c_str(), NULL, 16);
			uint8_t d[7];
			d[0] = (d64 >> 56) & 0xff; // data bytes 0..6
			d[1] = (d64 >> 48) & 0xff;
			d[2] = (d64 >> 40) & 0xff;
			d[3] = (d64 >> 32) & 0xff;
			d[4] = (d64 >> 24) & 0xff;
			d[5] = (d64 >> 16) & 0xff;
			d[6] = (d64 >>  8) & 0xff;
			uint8_t p = d64 & 0xff; // PEC byte

			sprintf (cmd, i2cset_block.c_str(), bus, chip.c_str(), reg.c_str(), d[0], d[1], d[2], d[3],d[4], d[5], d[6], p);
			run_command (cmd, output);
			printf ("%s = %s // %s\n", cmd, output.c_str(), comment.c_str());
			comment = ""; // reset comment so it does not persist for commands without comments
		}
		else if (fld[0].compare ("BlockRead") == 0)
		{
			// don't know how to read block using i2cget, skipping
		}
		else if (fld[0].compare ("SendByte") == 0)
		{
			chip = fld[1]; // can use as is
			reg  = fld[2]; // can use as is

			boost::trim(chip);
			boost::trim(reg);

			sprintf (cmd, i2cset_send.c_str(), bus, chip.c_str(), reg.c_str());
			run_command (cmd, output);
			printf ("%s = %s // %s\n", cmd, output.c_str(), comment.c_str());
			comment = ""; // reset comment so it does not persist for commands without comments
		}
		else if (fld[0].compare ("Pause") == 0)
		{
			uint64_t pause_time = strtoull(fld[1].c_str(), NULL, 10); // in ms
			usleep(pause_time * 1000);
		}
		else
			printf ("ERROR: Unknown command: %s", line); // unknown command



//		sprintf (cmd, i2cset, 0xff, bus, chip, rd.address & 0xff, rd.value);
//		run_command (cmd, output);
	}
	// set page back to 0
//	sprintf (cmd, i2cset, 0xff, bus, chip, 1, 0);
//	run_command (cmd, output);
//	printf ("%s = %s\n", cmd, output);
//	printf ("TS53681 configuration finished, a = %x\n", chip);


}
